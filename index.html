<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>POLIS — The Board Game</title>
  <link
    href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;900&family=Cinzel+Decorative:wght@400;700&family=EB+Garamond:ital,wght@0,400;0,500;1,400&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --marble: #f0e8d8;
      --marble2: #e8dcc8;
      --stone: #c8b89a;
      --terracotta: #b85c38;
      --terracotta2: #d4703a;
      --bronze: #7a5c2e;
      --bronze2: #9a7a42;
      --deep: #2a1a0e;
      --ink: #1a0e06;
      --blue-lapis: #1a3a6a;
      --blue-mid: #2a5a9a;
      --blue-light: #4a8acc;
      --red-deep: #7a1a10;
      --red-mid: #b83020;
      --red-light: #e04030;
      --gold: #c8a830;
      --gold2: #e8c840;
      --shadow: rgba(26, 14, 6, 0.5);
      --brass: #b87333;
      --copper: #cd7f32;
      --steel: #8a8a8a;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--deep);
      font-family: 'EB Garamond', serif;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px 10px;
      position: relative;
      overflow-x: hidden;
    }

    /* Subtle mosaic background */
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        repeating-linear-gradient(0deg, transparent, transparent 39px, rgba(200, 168, 48, 0.04) 40px),
        repeating-linear-gradient(90deg, transparent, transparent 39px, rgba(200, 168, 48, 0.04) 40px);
      pointer-events: none;
      z-index: 0;
    }

    /* Steampunk gears background */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background-image:
        url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" opacity="0.08"><g fill="%23c8a830"><circle cx="50" cy="50" r="35" fill="none" stroke="%23c8a830" stroke-width="4"/><circle cx="50" cy="50" r="25" fill="none" stroke="%23c8a830" stroke-width="2"/><circle cx="50" cy="50" r="6"/><rect x="47" y="15" width="6" height="15" rx="1"/><rect x="47" y="70" width="6" height="15" rx="1"/><rect x="15" y="47" width="15" height="6" rx="1"/><rect x="70" y="47" width="15" height="6" rx="1"/><rect x="29" y="24" width="6" height="15" rx="1" transform="rotate(45 50 50)"/><rect x="65" y="24" width="6" height="15" rx="1" transform="rotate(-45 50 50)"/><rect x="29" y="61" width="6" height="15" rx="1" transform="rotate(-45 50 50)"/><rect x="65" y="61" width="6" height="15" rx="1" transform="rotate(45 50 50)"/></g></svg>');
      animation: gears-rotate 120s linear infinite;
      pointer-events: none;
      z-index: 0;
      opacity: 0.6;
    }

    @keyframes gears-rotate {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    #app {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      padding: 0;
      width: 100%;
      max-width: 650px;
    }

    /* Floating decorative gears */
    #app::before,
    #app::after {
      position: absolute;
      font-size: 120px;
      opacity: 0.05;
      z-index: -1;
      pointer-events: none;
    }

    #app::before {
      content: '⚙';
      left: -80px;
      top: 40%;
      color: var(--brass);
      animation: gear-float 40s linear infinite;
    }

    #app::after {
      content: '⚙';
      right: -80px;
      top: 50%;
      color: var(--copper);
      animation: gear-float-reverse 35s linear infinite;
    }

    @keyframes gear-float {
      0% {
        transform: rotate(0deg) translateY(0);
      }

      50% {
        transform: rotate(180deg) translateY(-20px);
      }

      100% {
        transform: rotate(360deg) translateY(0);
      }
    }

    @keyframes gear-float-reverse {
      0% {
        transform: rotate(360deg) translateY(0);
      }

      50% {
        transform: rotate(180deg) translateY(20px);
      }

      100% {
        transform: rotate(0deg) translateY(0);
      }
    }

    /* ── HEADER ─────────────────────────────────── */
    .header {
      position: relative;
      z-index: 1;
      text-align: center;
      margin-bottom: 20px;
    }

    .header::before,
    .header::after {
      content: '⚙';
      position: absolute;
      font-size: 48px;
      color: var(--brass);
      opacity: 0.4;
      animation: gear-spin 20s linear infinite;
    }

    .header::before {
      left: -60px;
      top: 10px;
    }

    .header::after {
      right: -60px;
      top: 10px;
      animation: gear-spin-reverse 15s linear infinite;
    }

    @keyframes gear-spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    @keyframes gear-spin-reverse {
      from {
        transform: rotate(360deg);
      }

      to {
        transform: rotate(0deg);
      }
    }

    .header h1 {
      font-family: 'Cinzel Decorative', serif;
      font-size: clamp(28px, 6vw, 54px);
      color: var(--gold);
      text-shadow: 0 2px 8px var(--shadow), 0 0 40px rgba(200, 168, 48, 0.3);
      letter-spacing: 0.15em;
      line-height: 1;
    }

    .header .subtitle {
      font-family: 'Cinzel', serif;
      font-size: clamp(10px, 2vw, 14px);
      color: var(--stone);
      letter-spacing: 0.3em;
      margin-top: 6px;
      text-transform: uppercase;
    }

    .header .ornament {
      color: var(--gold);
      font-size: 20px;
      opacity: 0.6;
      display: block;
      margin: 6px 0;
      position: relative;
    }

    /* Animate gears in ornament */
    .header .ornament::before,
    .header .ornament::after {
      content: '';
      position: absolute;
      top: 0;
      width: 20px;
      height: 20px;
      display: inline-block;
    }

    /* ── PLAYER BANNERS ─────────────────────────── */
    .players {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      position: relative;
      z-index: 1;
      width: 100%;
      max-width: 600px;
    }

    .player-card {
      flex: 1;
      padding: 12px 16px;
      border-radius: 4px;
      border: 2px solid;
      position: relative;
      overflow: hidden;
      transition: all 0.3s;
    }

    .player-card::before {
      content: '⚙';
      position: absolute;
      font-size: 80px;
      right: -10px;
      bottom: -20px;
      opacity: 0.08;
      animation: gear-spin-slow 30s linear infinite;
    }

    @keyframes gear-spin-slow {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .player-card.blue {
      background: linear-gradient(135deg, rgba(26, 58, 106, 0.9) 0%, rgba(42, 90, 154, 0.8) 100%);
      border-color: var(--blue-light);
    }

    .player-card.red {
      background: linear-gradient(135deg, rgba(122, 26, 16, 0.9) 0%, rgba(184, 48, 32, 0.8) 100%);
      border-color: var(--red-light);
    }

    .player-card.active-turn {
      box-shadow: 0 0 20px 4px currentColor;
      transform: translateY(-2px);
    }

    .player-card.blue.active-turn {
      box-shadow: 0 0 20px 4px var(--blue-light);
    }

    .player-card.red.active-turn {
      box-shadow: 0 0 20px 4px var(--red-light);
    }

    .player-card .p-name {
      font-family: 'Cinzel', serif;
      font-size: 13px;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
    }

    .player-card.blue .p-name {
      color: var(--blue-light);
    }

    .player-card.red .p-name {
      color: var(--red-light);
    }

    .player-card .p-count {
      font-size: 22px;
      font-weight: bold;
      margin-top: 2px;
      color: var(--marble);
    }

    .player-card .p-label {
      font-size: 11px;
      color: var(--stone);
      font-style: italic;
    }

    .turn-arrow {
      font-size: 22px;
      display: flex;
      align-items: center;
      color: var(--gold);
      opacity: 0.7;
    }

    /* ── STATUS BAR ─────────────────────────────── */
    .status-bar {
      position: relative;
      z-index: 1;
      background:
        rgba(42, 26, 14, 0.8),
        repeating-linear-gradient(90deg, transparent 0, transparent 10px, rgba(184, 115, 51, 0.03) 10px, rgba(184, 115, 51, 0.03) 11px);
      border: 1px solid var(--bronze);
      border-radius: 4px;
      padding: 8px 20px;
      margin-bottom: 14px;
      font-family: 'Cinzel', serif;
      font-size: clamp(11px, 2vw, 14px);
      color: var(--marble);
      letter-spacing: 0.05em;
      text-align: center;
      min-height: 36px;
      max-width: 600px;
      width: 100%;
      transition: color 0.3s;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px 0 rgba(184, 115, 51, 0.2);
    }

    .status-bar::before,
    .status-bar::after {
      content: '⚙';
      position: absolute;
      font-size: 20px;
      color: var(--brass);
      opacity: 0.15;
      top: 50%;
      transform: translateY(-50%);
      animation: gear-spin-slow 25s linear infinite;
    }

    .status-bar::before {
      left: 6px;
    }

    .status-bar::after {
      right: 6px;
      animation: gear-spin-reverse 25s linear infinite;
    }

    .status-bar.phase-select {
      color: var(--gold2);
    }

    .status-bar.phase-hop {
      color: var(--stone);
    }

    .status-bar.phase-win {
      color: var(--gold);
      font-weight: bold;
      font-size: 16px;
    }

    .status-bar.phase-history {
      color: var(--bronze2);
      font-style: italic;
    }

    /* ── BOARD WRAPPER ──────────────────────────── */
    .board-wrap {
      position: relative;
      z-index: 1;
      background:
        linear-gradient(145deg, #3a2a1a, #2a1a0e),
        repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(184, 115, 51, 0.1) 2px, rgba(184, 115, 51, 0.1) 3px);
      border: 4px solid var(--bronze);
      border-radius: 6px;
      box-shadow:
        0 0 0 2px var(--gold),
        0 0 0 3px var(--brass),
        0 8px 40px var(--shadow),
        inset 0 0 40px rgba(0, 0, 0, 0.4),
        inset 0 0 4px rgba(184, 115, 51, 0.3);
      padding: 12px;
    }

    /* Rivets on board corners */
    .board-wrap::before,
    .board-wrap::after {
      content: '';
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--copper), var(--brass), #6d5a3a);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5), 0 1px 2px rgba(255, 255, 255, 0.2);
      z-index: 10;
    }

    .board-wrap::before {
      top: 8px;
      left: 8px;
    }

    .board-wrap::after {
      top: 8px;
      right: 8px;
    }

    /* Additional rivets for board */
    #board::before,
    #board::after {
      content: '';
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--copper), var(--brass), #6d5a3a);
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5), 0 1px 2px rgba(255, 255, 255, 0.2);
      z-index: 20;
      bottom: -18px;
    }

    #board::before {
      left: -24px;
    }

    #board::after {
      right: -24px;
    }

    .coord-row {
      display: flex;
      align-items: center;
    }

    .coord-labels-top,
    .coord-labels-bottom {
      display: flex;
      margin-left: 22px;
    }

    .coord-label {
      width: clamp(44px, 10vw, 64px);
      text-align: center;
      font-family: 'Cinzel', serif;
      font-size: 10px;
      color: var(--bronze2);
      letter-spacing: 0.1em;
    }

    .coord-side {
      width: 20px;
      flex-shrink: 0;
      font-family: 'Cinzel', serif;
      font-size: 10px;
      color: var(--bronze2);
      text-align: right;
      padding-right: 4px;
      display: flex;
      align-items: center;
      justify-content: flex-end;
    }

    /* ── BOARD GRID ─────────────────────────────── */
    #board {
      display: grid;
      grid-template-columns: repeat(8, clamp(44px, 10vw, 64px));
      grid-template-rows: repeat(8, clamp(44px, 10vw, 64px));
      border: 1px solid var(--bronze);
      position: relative;
      --cell-size: clamp(44px, 10vw, 64px);
    }

    #hop-svg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 10;
      overflow: visible;
    }

    #hop-svg line {
      stroke-dasharray: 5 4;
      stroke-linecap: round;
    }

    #hop-svg circle.hop-ghost {
      opacity: 0.5;
    }

    .cell {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: default;
      border: 1px solid rgba(122, 92, 46, 0.3);
      transition: background 0.15s;
      box-shadow: inset 0 0 2px rgba(184, 115, 51, 0.1);
    }

    .cell.light {
      background: var(--marble2);
    }

    .cell.dark {
      background: var(--stone);
    }

    .cell.valid-move {
      background: rgba(200, 168, 48, 0.25) !important;
      cursor: pointer;
    }

    .cell.valid-move::after {
      content: '';
      position: absolute;
      inset: 0;
      border: 2px solid var(--gold);
      pointer-events: none;
      animation: pulse 1s ease-in-out infinite alternate;
    }

    @keyframes pulse {
      from {
        opacity: 0.4;
      }

      to {
        opacity: 1;
      }
    }

    .cell.selected {
      background: rgba(200, 168, 48, 0.35) !important;
    }

    .cell.selected::after {
      content: '';
      position: absolute;
      inset: 0;
      border: 3px solid var(--gold2);
      pointer-events: none;
    }

    .cell.last-from {
      background: rgba(200, 168, 48, 0.55) !important;
    }

    .cell.last-to {
      background: rgba(200, 168, 48, 0.4) !important;
    }

    .cell.hopped-from {
      animation: hopFrom 0.4s ease;
    }

    .cell.hopped-to {
      animation: hopTo 0.4s ease;
    }

    @keyframes hopFrom {
      0% {
        opacity: 1
      }

      50% {
        opacity: 0.3
      }

      100% {
        opacity: 1
      }
    }

    @keyframes hopTo {
      0% {
        transform: scale(0.6);
        opacity: 0.5
      }

      100% {
        transform: scale(1);
        opacity: 1
      }
    }

    /* ── PIECES ─────────────────────────────────── */
    .piece {
      width: 76%;
      height: 76%;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(14px, 3vw, 20px);
      cursor: pointer;
      position: relative;
      z-index: 2;
      transition: transform 0.15s, box-shadow 0.15s;
      user-select: none;
      flex-shrink: 0;
    }

    .piece:hover {
      transform: scale(1.1);
    }

    .piece.selected-piece {
      transform: scale(1.15);
    }

    .piece.blue-dog {
      background: radial-gradient(circle at 35% 35%, #5a8acc, var(--blue-mid), var(--blue-lapis));
      border: 2px solid var(--blue-light);
      box-shadow:
        0 3px 8px rgba(0, 0, 0, 0.5),
        inset 0 1px 2px rgba(255, 255, 255, 0.2),
        inset 0 -8px 8px rgba(184, 115, 51, 0.08);
      color: #a8d0f8;
    }

    .piece.blue-chariot {
      background:
        radial-gradient(circle at 35% 35%, #6a9adc, #1a5aaa, #0a2a5a),
        repeating-linear-gradient(45deg, transparent 0, transparent 2px, rgba(184, 115, 51, 0.1) 2px, rgba(184, 115, 51, 0.1) 4px);
      border: 3px solid var(--gold);
      box-shadow:
        0 3px 12px rgba(0, 0, 0, 0.6),
        0 0 12px rgba(200, 168, 48, 0.3),
        0 0 8px rgba(184, 115, 51, 0.2),
        inset 0 1px 3px rgba(255, 255, 255, 0.3),
        inset 0 0 10px rgba(184, 115, 51, 0.15);
      color: var(--gold2);
      border-radius: 30% 30% 50% 50%;
      position: relative;
    }

    .piece.blue-chariot::after {
      content: '';
      position: absolute;
      width: 20%;
      height: 20%;
      border-radius: 50%;
      background: radial-gradient(circle, var(--copper), transparent);
      top: 15%;
      left: 15%;
      opacity: 0.3;
    }

    .piece.red-dog {
      background: radial-gradient(circle at 35% 35%, #e06050, var(--red-mid), var(--red-deep));
      border: 2px solid var(--red-light);
      box-shadow:
        0 3px 8px rgba(0, 0, 0, 0.5),
        inset 0 1px 2px rgba(255, 255, 255, 0.2),
        inset 0 -8px 8px rgba(184, 115, 51, 0.08);
      color: #f8b0a8;
    }

    .piece.red-chariot {
      background:
        radial-gradient(circle at 35% 35%, #f07060, #b02010, #6a0a08),
        repeating-linear-gradient(45deg, transparent 0, transparent 2px, rgba(184, 115, 51, 0.1) 2px, rgba(184, 115, 51, 0.1) 4px);
      border: 3px solid var(--gold);
      box-shadow:
        0 3px 12px rgba(0, 0, 0, 0.6),
        0 0 12px rgba(200, 168, 48, 0.3),
        0 0 8px rgba(184, 115, 51, 0.2),
        inset 0 1px 3px rgba(255, 255, 255, 0.3),
        inset 0 0 10px rgba(184, 115, 51, 0.15);
      color: var(--gold2);
      border-radius: 30% 30% 50% 50%;
      position: relative;
    }

    .piece.red-chariot::after {
      content: '';
      position: absolute;
      width: 20%;
      height: 20%;
      border-radius: 50%;
      background: radial-gradient(circle, var(--copper), transparent);
      top: 15%;
      left: 15%;
      opacity: 0.3;
    }

    .piece.stunned {
      opacity: 0.65;
      filter: saturate(0.4) brightness(0.8);
      border-style: dashed !important;
    }

    .piece.clickable {
      cursor: pointer;
    }

    .piece.clickable:hover {
      box-shadow:
        0 3px 12px rgba(0, 0, 0, 0.6),
        0 0 14px var(--gold2),
        0 0 8px var(--brass);
      transform: scale(1.12);
    }

    /* ── HOPPING ANIMATIONS ─────────────────────── */
    @keyframes hop-leap {
      0% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }

      50% {
        transform: scale(1.3) translateY(-15px);
        opacity: 0.9;
      }

      100% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
    }

    .piece.hopping {
      animation: hop-leap 0.5s ease-in-out;
    }

    .piece.fade-out-capture {
      animation: capture-fade 0.3s ease-out forwards;
    }

    @keyframes capture-fade {
      0% {
        opacity: 1;
        transform: scale(1);
      }

      100% {
        opacity: 0;
        transform: scale(0.6);
      }
    }

    /* ── BUTTONS ─────────────────────────────────── */
    .btn-row {
      position: relative;
      z-index: 1;
      display: flex;
      gap: 12px;
      margin-top: 14px;
      justify-content: center;
    }

    .btn,
    button {
      font-family: 'Cinzel', serif;
      font-size: 12px;
      letter-spacing: 0.1em;
      padding: 9px 22px;
      border: 2px solid var(--bronze2);
      background:
        linear-gradient(135deg, rgba(122, 92, 46, 0.6), rgba(90, 64, 24, 0.8)),
        repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(184, 115, 51, 0.05) 2px, rgba(184, 115, 51, 0.05) 4px);
      color: var(--marble);
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
      position: relative;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .btn::before,
    .btn::after,
    button::before,
    button::after {
      content: '';
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, var(--copper), var(--brass));
      box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.4);
      top: 50%;
      transform: translateY(-50%);
    }

    .btn::before,
    button::before {
      left: 6px;
    }

    .btn::after,
    button::after {
      right: 6px;
    }

    .btn:hover,
    button:hover {
      border-color: var(--gold);
      color: var(--gold2);
      background:
        linear-gradient(135deg, rgba(122, 92, 46, 0.8), rgba(90, 64, 24, 1)),
        repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(184, 115, 51, 0.08) 2px, rgba(184, 115, 51, 0.08) 4px);
      box-shadow: 0 0 12px rgba(200, 168, 48, 0.3), 0 2px 6px rgba(0, 0, 0, 0.4);
    }

    /* ── MODAL ──────────────────────────────────── */
    .modal-overlay {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.75);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.show {
      display: flex;
    }

    .modal-box {
      background:
        linear-gradient(145deg, #3a2812, #2a1a0c),
        repeating-linear-gradient(45deg, transparent 0, transparent 3px, rgba(184, 115, 51, 0.03) 3px, rgba(184, 115, 51, 0.03) 6px);
      border: 3px solid var(--gold);
      border-radius: 8px;
      padding: 40px 50px;
      text-align: center;
      box-shadow:
        0 0 60px rgba(200, 168, 48, 0.4),
        0 0 30px rgba(184, 115, 51, 0.2),
        inset 0 2px 8px rgba(0, 0, 0, 0.3);
      max-width: 400px;
      width: 90%;
      position: relative;
    }

    .modal-box::before,
    .modal-box::after {
      content: '⚙';
      position: absolute;
      font-size: 60px;
      color: var(--brass);
      opacity: 0.08;
      animation: gear-spin-slow 30s linear infinite;
    }

    .modal-box::before {
      top: 10px;
      left: 10px;
    }

    .modal-box::after {
      bottom: 10px;
      right: 10px;
      animation: gear-spin-reverse 30s linear infinite;
    }

    .modal-box h2 {
      font-family: 'Cinzel Decorative', serif;
      font-size: 28px;
      color: var(--gold);
      margin-bottom: 10px;
      text-shadow: 0 0 20px rgba(200, 168, 48, 0.5);
    }

    .modal-box p {
      font-size: 16px;
      color: var(--marble);
      margin-bottom: 24px;
      line-height: 1.6;
    }

    .modal-box .winner-icon {
      font-size: 48px;
      margin-bottom: 12px;
      display: block;
    }

    /* ── RULES PANEL ────────────────────────────── */
    .rules-toggle {
      position: relative;
      z-index: 1;
      margin-top: 14px;
      width: 100%;
      max-width: 620px;
    }

    .rules-toggle summary {
      font-family: 'Cinzel', serif;
      font-size: 12px;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--stone);
      cursor: pointer;
      padding: 8px 0;
      list-style: none;
      text-align: center;
    }

    .rules-toggle summary:hover {
      color: var(--gold);
    }

    .rules-content {
      background: rgba(42, 26, 14, 0.8);
      border: 1px solid var(--bronze);
      border-radius: 4px;
      padding: 16px 20px;
      margin-top: 6px;
      font-size: 13px;
      color: var(--marble2);
      line-height: 1.7;
      column-count: 2;
      column-gap: 20px;
    }

    .rules-content h4 {
      font-family: 'Cinzel', serif;
      font-size: 11px;
      color: var(--gold);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 4px;
      margin-top: 10px;
      column-span: all;
    }

    .rules-content h4:first-child {
      margin-top: 0;
    }

    /* ── SETUP MODAL ─────────────────────────── */
    .setup-row {
      display: flex;
      gap: 16px;
      justify-content: center;
      margin: 20px 0 16px;
    }

    .setup-player {
      flex: 1;
      padding: 14px 12px;
      border-radius: 4px;
      border: 2px solid;
      text-align: center;
    }

    .setup-player.blue {
      background: linear-gradient(135deg, rgba(26, 58, 106, 0.9) 0%, rgba(42, 90, 154, 0.8) 100%);
      border-color: var(--blue-light);
    }

    .setup-player.red {
      background: linear-gradient(135deg, rgba(122, 26, 16, 0.9) 0%, rgba(184, 48, 32, 0.8) 100%);
      border-color: var(--red-light);
    }

    .setup-player-label {
      font-family: 'Cinzel', serif;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 10px;
    }

    .setup-player.blue .setup-player-label {
      color: var(--blue-light);
    }

    .setup-player.red .setup-player-label {
      color: var(--red-light);
    }

    .setup-toggle {
      display: flex;
      gap: 6px;
      justify-content: center;
    }

    .setup-toggle button {
      font-size: 11px;
      padding: 6px 14px;
      border-color: var(--bronze);
      color: var(--stone);
    }

    .setup-toggle button::before,
    .setup-toggle button::after {
      display: none;
    }

    .setup-toggle.blue button.active {
      border-color: var(--blue-light);
      color: var(--marble);
      box-shadow: 0 0 10px rgba(74, 138, 204, 0.5);
    }

    .setup-toggle.red button.active {
      border-color: var(--red-light);
      color: var(--marble);
      box-shadow: 0 0 10px rgba(224, 64, 48, 0.5);
    }

    .setup-depth {
      margin: 16px 0 8px;
      text-align: center;
    }

    .setup-depth label {
      display: block;
      font-family: 'Cinzel', serif;
      font-size: 12px;
      color: var(--stone);
      letter-spacing: 0.1em;
      text-transform: uppercase;
      margin-bottom: 8px;
    }

    .setup-depth select {
      font-family: 'Cinzel', serif;
      font-size: 12px;
      letter-spacing: 0.05em;
      padding: 7px 24px;
      border: 2px solid var(--bronze2);
      background: linear-gradient(135deg, rgba(42, 26, 14, 0.9), rgba(26, 14, 6, 0.95));
      color: var(--marble);
      border-radius: 3px;
      cursor: pointer;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      text-align: center;
    }

    .setup-depth select:hover,
    .setup-depth select:focus {
      border-color: var(--gold);
      color: var(--gold2);
      box-shadow: 0 0 10px rgba(200, 168, 48, 0.3);
    }

    #depth-warning {
      font-style: italic;
      font-size: 12px;
      color: var(--terracotta2);
      margin-top: 6px;
      display: none;
    }

    #setup-start-btn {
      margin-top: 20px;
      font-size: 14px;
      padding: 10px 32px;
    }
  </style>
</head>

<body>
  <div id="app">
    <div class="header">
      <h1>POLIS</h1>
      <span class="ornament">❧ ⚜ ❧</span>
      <p class="subtitle">The Ancient Game of Strategy &amp; Maneuver</p>
    </div>

    <div class="players" id="players">
      <div class="player-card blue" id="card-blue">
        <div class="p-name">⚔ Blue — Achaea</div>
        <div class="p-count" id="blue-count">16</div>
        <div class="p-label">pieces remaining</div>
      </div>
      <div class="turn-arrow" id="turn-arrow">▶</div>
      <div class="player-card red" id="card-red">
        <div class="p-name">Persia — ⚔ Red</div>
        <div class="p-count" id="red-count">16</div>
        <div class="p-label">pieces remaining</div>
      </div>
    </div>

    <div class="status-bar" id="status">Select a piece to move.</div>

    <div class="board-wrap">
      <div class="coord-labels-top" id="col-labels-top"></div>
      <div class="coord-row">
        <div id="board-with-coords" style="display:flex; align-items:stretch;">
          <div id="row-labels-left" style="display:flex;flex-direction:column;"></div>
          <div id="board"></div>
          <div id="row-labels-right" style="display:flex;flex-direction:column;"></div>
        </div>
      </div>
      <div class="coord-labels-bottom" id="col-labels-bottom"></div>
    </div>

    <div class="btn-row">
      <button class="btn" onclick="showSetupModal()">⟳ New Game</button>
    </div>

    <details class="rules-toggle">
      <summary>▸ Quick Rules Reference ◂</summary>
      <div class="rules-content">
        <h4>Objective</h4>
        Move your Chariot (⚜) to the opposite back rank to win.
        <h4>Movement</h4>
        Move one piece per turn, one square in any direction (including diagonals). You cannot skip your turn.
        <h4>Hopping</h4>
        After a piece moves, all adjacent pieces hop to the opposite side. Exceptions: (1) destination must be empty;
        (2) a piece won't hop if an allied piece is "anchored" behind it along the hop axis; (3) stunned chariots don't
        hop.
        <h4>Capturing</h4>
        After hops resolve, any piece surrounded by enemies on both sides along the same axis is removed. Hops happen
        before captures — pieces may hop into or out of danger.
        <h4>Chariots</h4>
        Cannot be captured — if surrounded, they become Stunned (shown faded). Stunned chariots cannot move and do not
        hop or count for captures. They unstun when no longer surrounded.
        <h4>Illegal Moves</h4>
        You cannot move a piece into a square where it would be immediately captured or stunned.
      </div>
    </details>
  </div>

  <!-- Setup Modal -->
  <div class="modal-overlay" id="setupModal">
    <div class="modal-box" style="max-width:480px;">
      <h2>NEW GAME</h2>
      <p style="margin-bottom:0; font-size:13px; color:var(--stone); letter-spacing:0.1em; text-transform:uppercase;">
        Configure Players</p>
      <div class="setup-row">
        <div class="setup-player blue">
          <div class="setup-player-label">⚔ Blue — Achaea</div>
          <div class="setup-toggle blue">
            <button data-value="human" class="active" onclick="setPlayerType('blue','human')">Human</button>
            <button data-value="ai" onclick="setPlayerType('blue','ai')">AI</button>
          </div>
        </div>
        <div class="setup-player red">
          <div class="setup-player-label">Persia — ⚔ Red</div>
          <div class="setup-toggle red">
            <button data-value="human" onclick="setPlayerType('red','human')">Human</button>
            <button data-value="ai" class="active" onclick="setPlayerType('red','ai')">AI</button>
          </div>
        </div>
      </div>
      <div class="setup-depth">
        <label for="setup-depth">AI Depth</label>
        <select id="setup-depth" onchange="onDepthChange(this.value)">
          <option value="1" selected>1 – Hoplite</option>
          <option value="2">2 – Strategist</option>
          <option value="3">3 – Oracle</option>
          <option value="4">4 – Athena</option>
        </select>
        <div id="depth-warning">Depth 4 may be slow to respond.</div>
      </div>
      <button id="setup-start-btn" onclick="startGame()">▶ Start Game</button>
    </div>
  </div>

  <!-- Win Modal -->
  <div class="modal-overlay" id="winModal">
    <div class="modal-box">
      <span class="winner-icon" id="winIcon">⚜</span>
      <h2 id="winTitle">Victory!</h2>
      <p id="winText">Player wins!</p>
      <button class="btn" onclick="document.getElementById('winModal').classList.remove('show'); showSetupModal()">Play
        Again</button>
    </div>
  </div>

  <script>
    const ROWS = 8, COLS = 8;
    const DIRS = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
    const AXES = [[0, 1], [1, 0], [1, 1], [1, -1]];

    let board, currentPlayer, selectedCell, validMoves, gameOver, statusMsg, lastMove;
    let animationState = null; // Tracks current animation phase
    const aiPlayers = { blue: false, red: true }; // set to true to hand a team to the algorithm

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function makePiece(team, type) {
      return { team, type, stunned: false };
    }

    function cloneBoard(b) {
      return b.map(row => row.map(cell => cell ? { ...cell } : null));
    }

    function inBounds(r, c) {
      return r >= 0 && r < ROWS && c >= 0 && c < COLS;
    }

    // --- Game Logic ---

    function initGame() {
      board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
      // Blue: rows 0-1, chariot at (0,0)
      for (let r = 0; r < 2; r++)
        for (let c = 0; c < COLS; c++)
          board[r][c] = makePiece('blue', 'dog');
      board[0][0] = makePiece('blue', 'chariot');

      // Red: rows 6-7, chariot at (7,7)
      for (let r = 6; r < 8; r++)
        for (let c = 0; c < COLS; c++)
          board[r][c] = makePiece('red', 'dog');
      board[7][7] = makePiece('red', 'chariot');

      currentPlayer = 'blue';
      selectedCell = null;
      validMoves = [];
      gameOver = false;
      statusMsg = 'Achaea (Blue) begins. Select a piece to move.';
      lastMove = null;
      moveHistory.length = 0;
      viewIndex = null;
      saveSnapshot(0);
      const modal = document.getElementById('winModal');
      if (modal) modal.classList.remove('show');
      render();
      afterTurn();
    }

    function updateStun(b) {
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++) {
          const p = b[r][c];
          if (p && p.type === 'chariot')
            p.stunned = checkStunAt(b, r, c);
        }
    }

    function checkStunAt(b, r, c) {
      const p = b[r][c];
      if (!p || p.type !== 'chariot') return false;
      const enemy = p.team === 'blue' ? 'red' : 'blue';
      for (const [dr, dc] of AXES) {
        const r1 = r + dr, c1 = c + dc;
        const r2 = r - dr, c2 = c - dc;
        if (inBounds(r1, c1) && inBounds(r2, c2)) {
          const p1 = b[r1][c1], p2 = b[r2][c2];
          if (p1 && p1.team === enemy && p2 && p2.team === enemy && !p1.stunned && !p2.stunned)
            return true;
        }
      }
      return false;
    }

    function computeHops(b, toR, toC) {
      const mover = b[toR][toC];
      if (!mover) return [];
      const moverTeam = mover.team;

      const hops = [];
      for (const [dr, dc] of DIRS) {
        const nr = toR + dr, nc = toC + dc;
        const tr = toR - dr, tc = toC - dc;
        if (!inBounds(nr, nc) || !inBounds(tr, tc)) continue;

        const neighbor = b[nr][nc];
        if (!neighbor) continue;

        if (neighbor.type === 'chariot' && neighbor.stunned) continue;
        if (b[tr][tc] !== null) continue;

        if (neighbor.team !== moverTeam) {
          const defR = toR + 2 * dr, defC = toC + 2 * dc;
          if (inBounds(defR, defC)) {
            const defender = b[defR][defC];
            if (defender && defender.team === neighbor.team) continue;
          }
        }

        hops.push({ fromR: nr, fromC: nc, toR: tr, toC: tc, piece: neighbor });
      }
      return hops;
    }

    function resolveHops(b, toR, toC) {
      const hops = computeHops(b, toR, toC);

      // Apply simultaneously
      const pieces = hops.map(h => b[h.fromR][h.fromC]);
      hops.forEach(h => { b[h.fromR][h.fromC] = null; });
      hops.forEach((h, i) => { b[h.toR][h.toC] = pieces[i]; });
    }

    function getHopPreview(fromR, fromC, toR, toC) {
      const sim = cloneBoard(board);
      sim[toR][toC] = sim[fromR][fromC];
      sim[fromR][fromC] = null;
      updateStun(sim);
      return computeHops(sim, toR, toC);
    }

    function computeCaptures(b) {
      const captured = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const p = b[r][c];
          if (!p || p.type === 'chariot') continue; // chariots get stunned, not captured
          const enemy = p.team === 'blue' ? 'red' : 'blue';
          for (const [dr, dc] of AXES) {
            const r1 = r + dr, c1 = c + dc;
            const r2 = r - dr, c2 = c - dc;
            if (!inBounds(r1, c1) || !inBounds(r2, c2)) continue;
            const p1 = b[r1][c1], p2 = b[r2][c2];
            if (p1 && p1.team === enemy && !(p1.type === 'chariot' && p1.stunned) &&
              p2 && p2.team === enemy && !(p2.type === 'chariot' && p2.stunned)) {
              captured.push([r, c]);
              break;
            }
          }
        }
      }
      return captured;
    }

    function executeMoveSync(b, fromR, fromC, toR, toC) {
      // Non-animated version for simulations
      b[toR][toC] = b[fromR][fromC];
      b[fromR][fromC] = null;

      // Compute stun before hops
      updateStun(b);

      // Resolve hops
      resolveHops(b, toR, toC);

      // Recompute stun after hops
      updateStun(b);

      // Compute and apply captures
      const captured = computeCaptures(b);
      captured.forEach(([r, c]) => { b[r][c] = null; });

      // Recompute stun after captures
      updateStun(b);

      return captured;
    }

    async function executeMove(b, fromR, fromC, toR, toC) {
      // Phase 1: Move the main piece
      b[toR][toC] = b[fromR][fromC];
      b[fromR][fromC] = null;
      updateStun(b);
      render();
      await delay(250);

      // Phase 2: Calculate and animate hops
      const hops = computeHops(b, toR, toC);

      if (hops.length > 0) {
        // Mark hopping pieces for animation
        animationState = { hopping: hops.map(h => [h.fromR, h.fromC]) };
        render();
        await delay(500); // Duration of hop animation

        // Apply hops to board state
        const pieces = hops.map(h => b[h.fromR][h.fromC]);
        hops.forEach(h => { b[h.fromR][h.fromC] = null; });
        hops.forEach((h, i) => { b[h.toR][h.toC] = pieces[i]; });

        animationState = null;
        updateStun(b);
        render();
        await delay(200);
      }

      // Phase 3: Compute captures
      const captured = computeCaptures(b);

      // Phase 4: Animate captures
      if (captured.length > 0) {
        animationState = { capturing: captured };
        render();
        await delay(300); // Duration of capture animation

        // Remove captured pieces
        captured.forEach(([r, c]) => { b[r][c] = null; });
        animationState = null;
      }

      // Recompute stun after captures
      updateStun(b);

      return captured;
    }

    function isMoveLegal(b, fromR, fromC, toR, toC) {
      const piece = b[fromR][fromC];
      if (!piece) return false;
      if (!inBounds(toR, toC) || b[toR][toC] !== null) return false;
      const dr = Math.abs(toR - fromR), dc = Math.abs(toC - fromC);
      if (dr > 1 || dc > 1 || (dr === 0 && dc === 0)) return false;

      // Simulate full resolution on a clone
      const sim = cloneBoard(b);
      executeMoveSync(sim, fromR, fromC, toR, toC);

      // Check if moved piece survived
      const movedPiece = sim[toR][toC];
      if (!movedPiece) return false; // captured
      if (movedPiece.type === 'chariot' && movedPiece.stunned) return false;
      return true;
    }

    function getValidMoves(b, r, c) {
      const piece = b[r][c];
      if (!piece) return [];
      if (piece.type === 'chariot' && piece.stunned) return [];
      const moves = [];
      for (const [dr, dc] of DIRS) {
        const tr = r + dr, tc = c + dc;
        if (inBounds(tr, tc) && b[tr][tc] === null && isMoveLegal(b, r, c, tr, tc))
          moves.push([tr, tc]);
      }
      return moves;
    }

    function checkWin(b) {
      for (let c = 0; c < COLS; c++) {
        const p7 = b[7][c];
        if (p7 && p7.type === 'chariot' && p7.team === 'blue') return 'blue';
        const p0 = b[0][c];
        if (p0 && p0.type === 'chariot' && p0.team === 'red') return 'red';
      }
      return null;
    }

    function hasAnyMoves(b, player) {
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++) {
          const p = b[r][c];
          if (p && p.team === player && getValidMoves(b, r, c).length > 0) return true;
        }
      return false;
    }

    function countPieces(b, team) {
      let count = 0;
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++) {
          const p = b[r][c];
          if (p && p.team === team) count++;
        }
      return count;
    }

    // --- UI ---

    function cap(s) { return s[0].toUpperCase() + s.slice(1); }

    function render() {
      const inHistory = viewIndex !== null;
      const snap      = inHistory ? moveHistory[viewIndex] : null;
      const displayBoard  = inHistory ? snap.board         : board;
      const displayPlayer = inHistory ? snap.currentPlayer : currentPlayer;
      const displayLast   = inHistory ? snap.lastMove      : lastMove;

      const container = document.getElementById('board');
      container.innerHTML = '';

      // Add SVG overlay for hop previews
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.id = 'hop-svg';
      container.appendChild(svg);

      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          const isLight = (r + c) % 2 === 0;
          cell.className = 'cell ' + (isLight ? 'light' : 'dark');

          if (!inHistory && selectedCell && selectedCell[0] === r && selectedCell[1] === c)
            cell.classList.add('selected');

          const isValidMove = !inHistory && validMoves.some(([mr, mc]) => mr === r && mc === c);
          if (isValidMove)
            cell.classList.add('valid-move');

          if (displayLast) {
            if (displayLast.fromR === r && displayLast.fromC === c) cell.classList.add('last-from');
            if (displayLast.toR === r && displayLast.toC === c) cell.classList.add('last-to');
          }

          const piece = displayBoard[r][c];
          if (piece) {
            const el = document.createElement('div');
            el.className = `piece ${piece.team}-${piece.type}`;
            if (piece.stunned) el.classList.add('stunned');

            const isOwn = !inHistory && piece.team === displayPlayer && !(piece.type === 'chariot' && piece.stunned) && !aiPlayers[displayPlayer];
            if (isOwn && !gameOver) el.classList.add('clickable');

            if (!inHistory && selectedCell && selectedCell[0] === r && selectedCell[1] === c) {
              el.classList.add('selected-piece');
            }

            // Add hopping animation
            if (animationState && animationState.hopping) {
              const isHopping = animationState.hopping.some(([hr, hc]) => hr === r && hc === c);
              if (isHopping) el.classList.add('hopping');
            }

            // Add capture animation
            if (animationState && animationState.capturing) {
              const isCapturing = animationState.capturing.some(([cr, cc]) => cr === r && cc === c);
              if (isCapturing) el.classList.add('fade-out-capture');
            }

            el.textContent = piece.type === 'chariot' ? '⚜' : '●';
            cell.appendChild(el);
          }

          cell.addEventListener('click', () => handleClick(r, c));

          if (!inHistory && isValidMove && selectedCell) {
            const [fromR, fromC] = selectedCell;
            cell.addEventListener('mouseenter', () => drawHopPreview(fromR, fromC, r, c));
            cell.addEventListener('mouseleave', clearHopPreview);
          }

          container.appendChild(cell);
        }
      }

      // Update piece counts
      document.getElementById('blue-count').textContent = countPieces(displayBoard, 'blue');
      document.getElementById('red-count').textContent = countPieces(displayBoard, 'red');

      // Update player cards
      updateTurnCards(displayPlayer);

      // Update status
      const statusEl = document.getElementById('status');
      if (inHistory) {
        const total = moveHistory.length - 1;
        const label = snap.turnNum === 0 ? 'Start' : `Turn ${snap.turnNum}`;
        statusEl.textContent = `${label} / ${total}  ·  ← → to navigate  ·  Esc to return`;
        statusEl.className = 'status-bar phase-history';
      } else {
        statusEl.textContent = statusMsg;
        statusEl.className = 'status-bar';
      }
    }

    function cellCenter(r, c) {
      const svg = document.getElementById('hop-svg');
      if (!svg) return { x: 0, y: 0 };
      const w = svg.clientWidth / COLS;
      const h = svg.clientHeight / ROWS;
      return { x: c * w + w / 2, y: r * h + h / 2 };
    }

    function drawHopPreview(fromR, fromC, toR, toC) {
      const svg = document.getElementById('hop-svg');
      if (!svg) return;
      svg.innerHTML = '';

      const hops = getHopPreview(fromR, fromC, toR, toC);
      if (hops.length === 0) return;

      const cellW = svg.clientWidth / COLS;
      const cellH = svg.clientHeight / ROWS;
      const ghostR = cellW * 0.30;

      for (const hop of hops) {
        const from = cellCenter(hop.fromR, hop.fromC);
        const to = cellCenter(hop.toR, hop.toC);
        const color = hop.piece.team === 'blue' ? '#5ea8f5' : '#f55e5e';

        // Dotted line
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', from.x);
        line.setAttribute('y1', from.y);
        line.setAttribute('x2', to.x);
        line.setAttribute('y2', to.y);
        line.setAttribute('stroke', color);
        line.setAttribute('stroke-width', 2.2);
        line.setAttribute('stroke-opacity', 0.55);
        svg.appendChild(line);

        // Arrowhead
        const dx = to.x - from.x, dy = to.y - from.y;
        const len = Math.sqrt(dx * dx + dy * dy);
        if (len < 1) continue;
        const ux = dx / len, uy = dy / len;
        const tipX = to.x - ux * ghostR, tipY = to.y - uy * ghostR;
        const aSize = 6;
        const px = -uy, py = ux;
        const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
        arrow.setAttribute('points',
          `${tipX},${tipY} ${tipX - ux * aSize + px * aSize * 0.6},${tipY - uy * aSize + py * aSize * 0.6} ${tipX - ux * aSize - px * aSize * 0.6},${tipY - uy * aSize - py * aSize * 0.6}`
        );
        arrow.setAttribute('fill', color);
        arrow.setAttribute('opacity', '0.55');
        svg.appendChild(arrow);

        // Ghost circle at destination
        const ghost = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        ghost.setAttribute('cx', to.x);
        ghost.setAttribute('cy', to.y);
        ghost.setAttribute('r', ghostR);
        ghost.setAttribute('fill', color);
        ghost.setAttribute('opacity', '0.25');
        ghost.setAttribute('stroke', color);
        ghost.setAttribute('stroke-width', '1.5');
        ghost.setAttribute('stroke-opacity', '0.4');
        ghost.setAttribute('stroke-dasharray', '4 3');
        ghost.classList.add('hop-ghost');
        svg.appendChild(ghost);
      }
    }

    function clearHopPreview() {
      const svg = document.getElementById('hop-svg');
      if (svg) svg.innerHTML = '';
    }

    let isAnimating = false;
    const moveHistory = []; // Array of { board, currentPlayer, statusMsg, lastMove, turnNum }
    let viewIndex = null;   // null = live; number = index into moveHistory being viewed

    function saveSnapshot(turnNum) {
      moveHistory.push({ board: cloneBoard(board), currentPlayer, statusMsg, lastMove, turnNum });
    }

    // --- AI Player Code ---

    // Replace this function with your algorithm.
    // Receives a deep-cloned board and the team to move ('blue' or 'red').
    // Must return { fromR, fromC, toR, toC }, or null if no moves exist.
    function chooseMove(boardState, player) {
      if (player === 'red') { return chooseMoveRed(boardState, player) }
      if (player === 'blue') { return chooseMoveBlue(boardState, player) }
    }

    let depth = 1;
    function minimax(board, depth, alpha, beta, isMaximizing, player, enemy) {
      const winner = checkWin(board);
      if (winner === player) return Infinity;
      if (winner === enemy) return -Infinity;
      if (depth === 0) return evaluate(board, player);

      const currentTeam = isMaximizing ? player : enemy;
      if (!hasAnyMoves(board, currentTeam))
        return isMaximizing ? -Infinity : Infinity;

      let best = isMaximizing ? -Infinity : Infinity;

      search:
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++) {
          const p = board[r][c];
          if (!p || p.team !== currentTeam) continue;
          for (const [toR, toC] of getValidMoves(board, r, c)) {
            const sim = cloneBoard(board);
            executeMoveSync(sim, r, c, toR, toC);
            const score = minimax(sim, depth - 1, alpha, beta, !isMaximizing, player, enemy);
            if (isMaximizing) {
              best = Math.max(best, score);
              alpha = Math.max(alpha, score);
            } else {
              best = Math.min(best, score);
              beta = Math.min(beta, score);
            }
            if (beta <= alpha) break search;
          }
        }

      return best;
    }

    // Score the board from `player`'s perspective.
    function evaluate(board, player) {
      const enemy = player === 'blue' ? 'red' : 'blue';

      // Piece count
      let score = countPieces(board, player) - countPieces(board, enemy);

      // Chariot advancement (quadratic — rewards being close to the far rank)
      score += chariotAdvancement(board, player);
      score -= chariotAdvancement(board, enemy);

      return score;
    }

    // Returns how far `team`'s chariot has advanced toward its goal rank, squared.
    // Blue advances from row 0 → 7; red advances from row 7 → 0.
    function chariotAdvancement(board, team) {
      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++) {
          const p = board[r][c];
          if (p && p.team === team && p.type === 'chariot') {
            const advancement = team === 'blue' ? r : (ROWS - 1 - r);
            if (r === ROWS - 1) { return 100 }
            return (1 / 10) * advancement * advancement; // 0 at start, 4.9 at far rank
          }
        }
      return 0; // chariot not found (shouldn't happen mid-game)
    }

    function chooseMoveRed(boardState, player) {
      const enemy = player === 'blue' ? 'red' : 'blue';
      let bestScore = -Infinity;
      let bestMoves = [];

      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++) {
          const p = boardState[r][c];
          if (!p || p.team !== player) continue;
          for (const [toR, toC] of getValidMoves(boardState, r, c)) {
            const sim = cloneBoard(boardState);
            executeMoveSync(sim, r, c, toR, toC);
            const score = minimax(sim, depth - 1, -Infinity, Infinity, false, player, enemy);
            if (score > bestScore) {
              bestScore = score;
              bestMoves = [{ fromR: r, fromC: c, toR, toC }];
            } else if (score === bestScore) {
              bestMoves.push({ fromR: r, fromC: c, toR, toC });
            }
          }
        }

      const randomIndex = Math.floor(Math.random() * bestMoves.length);
      return bestMoves[randomIndex];
    }

    function chooseMoveBlue(boardState, player) {
      const enemy = player === 'blue' ? 'red' : 'blue';
      let bestScore = -Infinity;
      let bestMoves = [];

      for (let r = 0; r < ROWS; r++)
        for (let c = 0; c < COLS; c++) {
          const p = boardState[r][c];
          if (!p || p.team !== player) continue;
          for (const [toR, toC] of getValidMoves(boardState, r, c)) {
            const sim = cloneBoard(boardState);
            executeMoveSync(sim, r, c, toR, toC);
            const score = minimax(sim, depth - 1, -Infinity, Infinity, false, player, enemy);
            if (score > bestScore) {
              bestScore = score;
              bestMoves = [{ fromR: r, fromC: c, toR, toC }];
            } else if (score === bestScore) {
              bestMoves.push({ fromR: r, fromC: c, toR, toC });
            }
          }
        }

      const randomIndex = Math.floor(Math.random() * bestMoves.length);
      return bestMoves[randomIndex];
    }

    // --- End AI Players ---

    async function runAiTurn() {
      if (gameOver || isAnimating || viewIndex !== null) return;
      const move = chooseMove(cloneBoard(board), currentPlayer);
      if (move) await applyMove(move.fromR, move.fromC, move.toR, move.toC);
    }

    function afterTurn() {
      if (!gameOver && aiPlayers[currentPlayer])
        setTimeout(runAiTurn, 400);
    }

    async function applyMove(fromR, fromC, toR, toC) {
      isAnimating = true;
      lastMove = { fromR, fromC, toR, toC };

      const captured = await executeMove(board, fromR, fromC, toR, toC);

      // Build status
      const msgs = [];
      if (captured.length > 0)
        msgs.push(`${captured.length} piece${captured.length > 1 ? 's' : ''} captured!`);

      for (let sr = 0; sr < ROWS; sr++)
        for (let sc = 0; sc < COLS; sc++) {
          const sp = board[sr][sc];
          if (sp && sp.type === 'chariot' && sp.stunned) {
            const teamName = sp.team === 'blue' ? 'Achaea' : 'Persia';
            msgs.push(`${teamName} chariot is stunned!`);
          }
        }

      statusMsg = msgs.join(' ');

      // Check win
      const winner = checkWin(board);
      if (winner) {
        gameOver = true;
        selectedCell = null;
        validMoves = [];
        saveSnapshot(moveHistory.length);
        isAnimating = false;
        render();
        showWin(winner, 'Chariot reached the final rank!');
        return;
      }

      // Switch turns
      currentPlayer = currentPlayer === 'blue' ? 'red' : 'blue';
      selectedCell = null;
      validMoves = [];

      if (!hasAnyMoves(board, currentPlayer)) {
        gameOver = true;
        const w = currentPlayer === 'blue' ? 'red' : 'blue';
        saveSnapshot(moveHistory.length);
        isAnimating = false;
        render();
        showWin(w, `${currentPlayer === 'blue' ? 'Achaea' : 'Persia'} has no valid moves!`);
        return;
      }

      const teamName = currentPlayer === 'blue' ? 'Achaea (Blue)' : 'Persia (Red)';
      if (!statusMsg) statusMsg = `${teamName}'s turn.`;
      saveSnapshot(moveHistory.length);
      isAnimating = false;
      render();
      afterTurn();
    }

    async function handleClick(r, c) {
      if (gameOver || isAnimating || aiPlayers[currentPlayer] || viewIndex !== null) return;

      // Clicking a valid move destination
      if (selectedCell && validMoves.some(([mr, mc]) => mr === r && mc === c)) {
        const [fromR, fromC] = selectedCell;
        selectedCell = null;
        validMoves = [];
        await applyMove(fromR, fromC, r, c);
        return;
      }

      // Clicking own piece
      const piece = board[r][c];
      if (piece && piece.team === currentPlayer) {
        if (piece.type === 'chariot' && piece.stunned) {
          selectedCell = null;
          validMoves = [];
          statusMsg = 'Your chariot is stunned and cannot move!';
          render();
          return;
        }
        const moves = getValidMoves(board, r, c);
        if (moves.length > 0) {
          selectedCell = [r, c];
          validMoves = moves;
          const pName = piece.type === 'chariot' ? 'Chariot' : 'Dog';
          statusMsg = `${pName} selected. ${moves.length} move${moves.length > 1 ? 's' : ''} available. Click a highlighted square.`;
        } else {
          selectedCell = [r, c];
          validMoves = [];
          statusMsg = 'This piece has no valid moves. Try another.';
        }
        render();
        return;
      }

      // Clicking elsewhere: deselect
      selectedCell = null;
      validMoves = [];
      const teamName = currentPlayer === 'blue' ? 'Achaea (Blue)' : 'Persia (Red)';
      statusMsg = `${teamName}'s turn. Select a piece to move.`;
      render();
    }

    function updateTurnCards(player = currentPlayer) {
      const blueCard = document.getElementById('card-blue');
      const redCard = document.getElementById('card-red');
      const arrow = document.getElementById('turn-arrow');

      if (gameOver) {
        blueCard.classList.remove('active-turn');
        redCard.classList.remove('active-turn');
      } else {
        blueCard.classList.toggle('active-turn', player === 'blue');
        redCard.classList.toggle('active-turn', player === 'red');
        arrow.style.transform = player === 'red' ? 'scaleX(-1)' : 'scaleX(1)';
      }
    }

    function showWin(winner, reason) {
      const name = winner === 'blue' ? 'Achaea (Blue)' : 'Persia (Red)';
      const icon = winner === 'blue' ? '🔵' : '🔴';
      document.getElementById('winIcon').textContent = icon;
      document.getElementById('winTitle').textContent = 'VICTORY!';
      document.getElementById('winText').textContent = `${name} wins! ${reason}`;
      document.getElementById('winModal').classList.add('show');
      statusMsg = `⚜ ${name} wins! ${reason}`;
    }

    function buildCoords() {
      const cols = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
      const cellW = 'clamp(44px,10vw,64px)';

      ['col-labels-top', 'col-labels-bottom'].forEach(id => {
        const el = document.getElementById(id);
        el.style.cssText = `display:flex; margin-left:22px;`;
        cols.forEach(l => {
          const d = document.createElement('div');
          d.className = 'coord-label';
          d.textContent = l;
          el.appendChild(d);
        });
      });

      ['row-labels-left', 'row-labels-right'].forEach((id, side) => {
        const el = document.getElementById(id);
        el.style.cssText = `display:flex;flex-direction:column;width:20px;`;
        for (let r = 1; r <= 8; r++) {
          const d = document.createElement('div');
          d.className = 'coord-side';
          d.style.cssText = `height:clamp(44px,10vw,64px);display:flex;align-items:center;justify-content:${side === 0 ? 'flex-end' : 'flex-start'};font-family:'Cinzel',serif;font-size:10px;color:var(--bronze2);padding:${side === 0 ? '0 4px 0 0' : '0 0 0 4px'}`;
          d.textContent = r;
          el.appendChild(d);
        }
      });
    }

    function showSetupModal() {
      document.getElementById('setupModal').classList.add('show');
    }

    function setPlayerType(team, value) {
      document.querySelectorAll(`.setup-toggle.${team} button`).forEach(b => {
        b.classList.toggle('active', b.dataset.value === value);
      });
    }

    function onDepthChange(value) {
      document.getElementById('depth-warning').style.display = value === '4' ? 'block' : 'none';
    }

    function startGame() {
      aiPlayers.blue = document.querySelector('.setup-toggle.blue button.active').dataset.value === 'ai';
      aiPlayers.red = document.querySelector('.setup-toggle.red button.active').dataset.value === 'ai';
      depth = parseInt(document.getElementById('setup-depth').value, 10);
      document.getElementById('setupModal').classList.remove('show');
      initGame();
    }

    // --- History Navigation ---
    document.addEventListener('keydown', e => {
      if (isAnimating) return;
      if (e.key === 'ArrowLeft') {
        if (viewIndex === null) {
          if (moveHistory.length === 0) return;
          viewIndex = moveHistory.length - 1;
        } else if (viewIndex > 0) {
          viewIndex--;
        }
        render();
      } else if (e.key === 'ArrowRight') {
        if (viewIndex === null) return;
        if (viewIndex < moveHistory.length - 1) {
          viewIndex++;
        } else {
          viewIndex = null;
          afterTurn(); // resume AI if it was waiting
        }
        render();
      } else if (e.key === 'Escape' && viewIndex !== null) {
        viewIndex = null;
        afterTurn();
        render();
      }
    });

    // --- Init ---
    buildCoords();
    showSetupModal();
  </script>
</body>

</html>